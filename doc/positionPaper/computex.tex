\section{Example data and Index computation process}

\TODO{A small screen capture}

\section{Data Model and Computex Ontology}

\TODO{Talk about the Computex ontology of statistical computations}

\subsection{Computex Ontology}
The \emph{Computex}\footnoteUrl{http://purl.org/weso/computex} vocabulary 
defines terms related to the computation of statistical index data. 
It is an specialization of the RDF Data Cube vocabulary~\cite{Cube} and is 
 compatible with it.

List of terms:

\begin{itemize}
\item\textbf{Indicator}

\item\textbf{Concept}

\item\textbf{Observation}. An observation. 
 It contains at least values for the properties:
   \lstinline|cex:value|, 
   \lstinline|cex:indicator| and 
   \lstinline|cex:concept|

\item\textbf{Computation} we have declared the main computation types that we
have needed for the WebIndex project, which have been summarized in
table~\ref{table:computations}. That list of computation types is not exhaustive
and can be further extended in the future. 

\item\textbf{WeightSchema} a weight schema for a list of indicators.

\end{itemize}

\begin{table*}[htb]
\caption{Some types of statistical computations}
\label{table:computations}
\begin{center}
\begin{tabular}{ p{0.2\textwidth} p{0.5\textwidth} p{0.3\textwidth}}
\toprule
Computation & Description & Properties \\
\hline
Mean	    & Mean of a set of observations 
			& \lstinline|cex:observation| \\
Increment	& Increment an observation by a given amount 
			& \lstinline|cex:observation| \lstinline|amount|  \\
Raw			& No computation. Raw value obtained from external source.
			&  \\
Copy		& A copy of another observation 
			& \lstinline|cex:observation| \\
Z-score		& A normalization of an observation using the values from a Slice. 
			& \lstinline|cex:observation| \lstinline|cex:slice| \\
Ranking		& Position in the ranking of a slice of observations. 
			& \lstinline|cex:observation| \lstinline|cex:slice| \\
AverageGrowth(N)	& Expected average growth of N observations
			& \lstinline|cex:observations| a collection of observations \\
WeightedMean & Weighted mean of an observation
			& \lstinline|cex:observation| 
			  \lstinline|cex:slice|
			  \lstinline|cex:weightSchema| \\
\bottomrule\\
\end{tabular}
\end{center}
\end{table*}

\section{Validation approach}

The validation approach was inspired by the integrity constraint specification
 proposed by the RDF Data Cube vocabulary which employs a set of SPARQL ASK queries
 to check the integrity of RDF Data Cube data. 
 Although SPARQL ASK queries provide a good means to check the integrity, in practice
  their boolean nature does not offer too much help when a file does not validate.
 To solve that issue, we defined CONSTRUCT queries which, in case of error, 
  construct an error message and a list of error parameters that can help to spot the
  problematic data.

 We have also transformed the ASK queries defined in the RDF Data Cube
 vocabulary to CONSTRUCT queries. For example, SPARQL construct query to validate the RDF Data Cube integrity
 constraint 4 (IC-4) is:
 
\begin{lstlisting}[style=SPARQL]
CONSTRUCT {
 [ a cex:Error ;
   cex:errorParam 
	[cex:name "dim"; cex:value ?dim ] ;
   cex:msg 
    "Every Dimension must have a declared range" . ]
} WHERE {
  ?dim a qb:DimensionProperty .
  FILTER NOT EXISTS { ?dim rdfs:range [] }
}
\end{lstlisting}
 
 In order to make our error messages compatible with EARL~\cite{EARL}, we have
 defined \lstinline|cex:Error| as a subclass of \lstinline|earl:TestResult| and 
 declared it to have the value \lstinline|earl:failed| for the property
 \lstinline|earl:outcome|.
 
 We have also created our own set of SPARQL Construct queries to validate the
 \emph{Computex} vocabulary terms, specially the computation of index data.

For example, the following query validates that every observation 
  has at most one value.
 
\begin{lstlisting}[style=SPARQL]
CONSTRUCT {
 [ a cex:Error ;
     cex:errorParam 
	  [cex:name "obs" ; cex:value ?obs ] ,
	  [cex:name "value1"; cex:value ?value1 ],
	  [cex:name "value2"; cex:value ?value2 ] ;
    cex:msg "Observation has two different values" . ]
} WHERE {
 ?obs a qb:Observation .
 ?obs cex:value ?value1 .
 ?obs cex:value ?value2 .
 FILTER ( ?value1 != ?value2  )
}
\end{lstlisting}

Using this approach, we have been able to develop more expressive validations.
For example, we were able to validate that an observation was obtained as the
mean of other observations. 

\begin{lstlisting}[style=SPARQL]
CONSTRUCT {
 [ a cex:Error ;
   cex:errorParam 
  [cex:name "obs" ; cex:value ?obs ] ,
  [cex:name "val"; cex:value ?val ],
  [cex:name "?mean"; cex:value ?mean ] ;
  cex:msg "Mean value does not match" ] .
} WHERE {  
  ?obs a qb:Observation ;
       cex:computation ?comp ;
       cex:value ?val .
  ?comp a cex:Mean .
  { SELECT (AVG(?value) as ?mean) ?comp WHERE {
     ?comp cex:observation ?obs1 .
	 ?obs1 cex:value ?value ;
  } GROUP BY ?comp } 
 FILTER( abs(?mean - ?val) > 0.0001)
}
\end{lstlisting}

Show some queries.

\section{Expressivity limits of SPARQL queries}

Validating statistical computations using SPARQL queries offered 
 a good exercise to check SPARQL expressivity. Although we were able 
 to express most of the computation types. 
Some of them had to employ functions that are not part of the SPARQL 1.1
standard or had to be defined in a limited way. In this section we review 
the main difficulties.

\begin{itemize} 

\item The Z-score of a value $x_i$ is defined as $\frac{x - \bar{x}}{\sigma}$
where $\bar{x}$ is the mean and $\sigma=\sqrt{\frac{\sum_{i=1}^{N}(\bar{x}-x_i)^2}{N -
1}}$ is the standard deviation. To validate that computation using SPARQL
queries, it is necessary to employ the \lstinline|sqrt| function. 
This function is not available in SPARQL 1.1 although some implementations 
 like Apache Jena ARQ provide it.

\item 
ranking need better XPath functions

\item average growth

\end{itemize}
